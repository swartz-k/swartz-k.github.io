<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Golang 中的领域驱动设计 - 战术设计 | ax for swartz</title>
<meta name=keywords content="Go,DDD">
<meta name=description content="上篇文章中我们讲了在 Golang 中实现领域驱动设计 DDD 相关的战略设计，这一篇我们会提供更多代码示例，从战术层面讲一讲应该如何做！">
<meta name=author content="Damiano Petrungaro">
<link rel=canonical href=https://www.ax4j.com/posts/ddd-using-golang-tactical-design/>
<meta name=google-site-verification content="H5OO9q7pK3NEE791os6zoOFNgDu4vSc2XDI32djnlFk">
<meta name=yandex-verification content="XYZabc">
<meta name=msvalidate.01 content="XYZabc">
<link crossorigin=anonymous href=/assets/css/stylesheet.min.ae5fee5abe0c35a3a51232a392a01818220338742898acc87247a70839adf4ff.css integrity="sha256-rl/uWr4MNaOlEjKjkqAYGCIDOHQomKzIckenCDmt9P8=" rel="preload stylesheet" as=style>
<link rel=preload href=/imgs/td_pixel_64.png as=image>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://www.ax4j.com/%3Clink%20/%20abs%20url%3E>
<link rel=icon type=image/png sizes=16x16 href=https://www.ax4j.com/%3Clink%20/%20abs%20url%3E>
<link rel=icon type=image/png sizes=32x32 href=https://www.ax4j.com/%3Clink%20/%20abs%20url%3E>
<link rel=apple-touch-icon href=https://www.ax4j.com/imgs/td_pixel_64.png>
<link rel=mask-icon href=https://www.ax4j.com/%3Clink%20/%20abs%20url%3E>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.89.1">
<link rel=stylesheet href=https://cdn.jsdelivr.net/gh/tonsky/FiraCode@5.2/distr/fira_code.css>
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-SGLCM9NH2B"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-SGLCM9NH2B',{anonymize_ip:!1})}</script>
<meta property="og:title" content="Golang 中的领域驱动设计 - 战术设计">
<meta property="og:description" content="上篇文章中我们讲了在 Golang 中实现领域驱动设计 DDD 相关的战略设计，这一篇我们会提供更多代码示例，从战术层面讲一讲应该如何做！">
<meta property="og:type" content="article">
<meta property="og:url" content="https://www.ax4j.com/posts/ddd-using-golang-tactical-design/"><meta property="og:image" content="https://www.ax4j.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-11-13T16:17:21+08:00">
<meta property="article:modified_time" content="2021-11-13T16:17:21+08:00"><meta property="og:site_name" content="ax for swartz">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://www.ax4j.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E">
<meta name=twitter:title content="Golang 中的领域驱动设计 - 战术设计">
<meta name=twitter:description content="上篇文章中我们讲了在 Golang 中实现领域驱动设计 DDD 相关的战略设计，这一篇我们会提供更多代码示例，从战术层面讲一讲应该如何做！">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.ax4j.com/posts/"},{"@type":"ListItem","position":2,"name":"Golang 中的领域驱动设计 - 战术设计","item":"https://www.ax4j.com/posts/ddd-using-golang-tactical-design/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Golang 中的领域驱动设计 - 战术设计","name":"Golang 中的领域驱动设计 - 战术设计","description":"上篇文章中我们讲了在 Golang 中实现领域驱动设计 DDD 相关的战略设计，这一篇我们会提供更多代码示例，从战术层面讲一讲应该如何做！","keywords":["Go","DDD"],"articleBody":" 译自 Domain Driven Design in Golang - Tactical Design - by - Damiano Petrungaro\n 在过去的几周里，我收到了很多关于我写的 Golang 和领域驱动设计系列的第一篇文章的私下和公开的问题。\n我私下收到的大多数问题都是关于如何使用 DDD 战术模式编写整个 Golang 项目（或一般代码）。\n所以我决定解决其中的一些问题，我将更广泛地解释我对 Golang 和 DDD 的看法，描述我使用的一些代码模式和我一直考虑的权衡。\n战术设计 在开始之前，我认为必须定义什么是战术设计。\n战术设计描述了一组模式，用于将领域分析中定义的常量和模型转化为代码，通常由战略设计驱动。应用这些模式的最终目标是以简单但富有表现力和安全的方式对代码进行建模。\n战术模式在 PHP、Java 和 C# 等语言社区中广为人知，因为当今可用的有关 DDD 模式的资源大多是面向对象的，但这并不意味着将这些概念应用到有不同范式的语言中是困难或错误的。\n我将在本文中介绍最著名和最常用的例子：\n 值对象（或值类型） 实体、聚合和聚合根 存储库  在一一描述源自 DDD 文献的所有模式之前，我想换个方向。\n我将从 始终有效的状态 这一概念开始，因为它会影响编写代码的方式。\n始终有效的状态 关于 始终有效的状态 的想法是，当一个类型不符合其上下文的常量时，不应创建该类型。\n有很多方法可以实现这个目标：添加一个验证 HTTP 的中间件，创建一个验证 CLI 输入的函数，或者将验证与保护常量的类型结合起来。\n每种方式都有它的好处和坏处；我们有责任评估这些选项并为我们的场景选择最好的，同时考虑定义这些规则的编程语言。\n谈到这些是因为，在 Golang 中，没有办法阻止在无效状态下创建类型。\n 无法实现的始终有效状态\n 让我们快速定义一个领域，并将其主要组件建模为代码。\n XYZ 是一款帮助你整理浏览器标签和书签的产品，能够与你常打开的标签进行交互。它允许客户创建书签集合并在工作区中共享这些集合，从而为每个工作区创建简单、分类和专业化的用户体验。\n 该领域内容都是关于标签和书签的。\n在分析过程中定义了我们领域的通用语言之后，我们需要编码的元素之一是选项卡的标题。\n标题 必须是 1 到 50 个字符之间的字符串，并且 不能为空。\n选项卡及其标题可以这样编码：\n// tab/tab.go package tab type Tab struct { Title string } // cmd/app/main.go package main import \"tab\" func main() { t := Tab{Title:\"\"} // ... } 在第一次迭代中，只需要几行代码，非常简洁！\n但是在 main.go 文件中刚刚创建了一个标题为空的 Tab；这种情况不应该发生在我们的领域，因为存在需要保护的常量。\n我们需要解决它。\n可以通过添加一些验证规则来保护领域内的字段：\n// tab/tab.go package tab import ( \"errors\" ) type Tab struct { Title string } func New(t string) (*Tab, error) { switch l := len(t); { case l 1: return nil, errors.New(\"tab: could not use title less than 1 char\") case l  50: return nil, errors.New(\"tab: could not use title more than 50 char\") default: return \u0026Tab{Title:t}, nil } } // cmd/app/main.go package main import \"tab\" func main() { t, err := Tab.New(\"a valid title\") if err != nil { panic(err) } t.Title = \"\" // ... } 现在似乎比以前好多了；保护领域的验证规则位于新的生成函数中。\n但同样，我们仍然能够使标题这一字段无效，因为 Go 提供的关于是否对外暴露、外部包访问的语言机制允许这样做。\n这可以防止 Tab 结构体的字段对外暴露，因为引用它的包无法访问这些私有字段：\n// tab/tab.go package tab import ( \"errors\" ) type Tab struct { title string } func New(t string) (*Tab, error) { switch l := len(t); { case l 1: return nil, errors.New(\"tab: could not use title less than 1 char\") case l  50: return nil, errors.New(\"tab: could not use title more than 50 char\") default: return \u0026Tab{title:t}, nil } } // cmd/app/main.go package main import \"tab\" func main() { t, err := tab.New(\"a valid title\") if err != nil { panic(err) } t2 := \u0026tab.Tab{} // ... } 最终创建了一个有效的 Title 并将其分配给变量 t，显然我们不能再更改它了。\n但是 t2 处于无效状态，它没有标题，或者更准确地说，它具有字符串类型的零值。\n每次在应用程序的任何函数中给出 Title 类型的零值时，可能会更加防御并返回错误。\n你可能已经注意到，由于 Golang 的机制，无法通过设计在 Golang 中实现始终有效的状态。\n与其自掘坟墓试图实现无法实现的目标，不如从不同的角度来解决这个问题。\n 寻找平衡\n 作为一名工程师，我日常工作的一部分是评估权衡，尽可能减少领域类型的安全问题和替代方案可能带来的简单性之间的技术债务平衡。\n我从 Golang 社区接受的理念之一是 API 包设计；设计一个包时应该考虑到用户将要使用它的用途。\n这种哲学选择是用于类型设计和实现战术模式的完美平衡。\n我应用这一理念，公开与包安全交互所需的 API，并授权用户决定它的使用，这意味着如果用户不使用包。\n无论如何，在某些情况下，更严格地围绕包的 API 采取行动是有意义的，尤其是在公司环境中。\n例如，在一个不停地推送特性的团队中，很难跟踪所有的变化，在一些包中添加更多的保护有助于尊重域不变量，减少错误的数量。\n但在添加防御性代码之前，必须明确这一需求，衡量由于缺乏保护而导致的错误、中断和事件的数量，因为这些额外的防御性方法会增加复杂性。\n注意：Google 定义了一种很好的方法，你可以扩展并使用它来跟踪这些事件，有关 SRE 的更多信息。如何用 Golang 实现战术设计模式 从现在开始我的主要目标是实现 DDD 模式而不陷入 OOP 陷阱，并利用语言机制来减少 API 和 package 耦合。\n# 值对象（或值类型） 我确实在 Golang 中将它们称为值类型，因为在这种语言中，没有 对象 的概念；对象 这个词可能误导你去思考面向对象。\n值类型是 DDD 文献中描述的一种模式，用于将相关事物分组为一个不可变单元，可通过组成它的属性进行比较。\npackage tab import ( \"errors\" \"fmt\" \"strings\" ) const ( minTitleLength = 1 maxTitleLength = 50 ) var ( // Errors used when an invalid title is given \tErrInvalidTitle = errors.New(\"tab: could not use invalid title\") ErrTitleTooShort = fmt.Errorf(\"%w: min length allowed is %d\", ErrInvalidTitle, minTitleLength) ErrTitleTooLong = fmt.Errorf(\"%w: max length allowed is %d\", ErrInvalidTitle, maxTitleLength) ) // Title represents a tab title type Title string // NewTitle returns a title and an error back func NewTitle(d string) (Title, error) { switch l := len(strings.TrimSpace(d)); { case l minTitleLength: return \"\", ErrTitleTooShort case l  maxTitleLength: return \"\", ErrTitleTooLong default: return Title(d), nil } } // String returns a string representation of the title func (t Title) String() string { return string(t) } // Equals returns true if the titles are equal func (t Title) Equals(t2 Title) bool { return t.String() == t2.String() } |值类型设计选择和优势 值类型有利于将域中的概念表示为代码，具有领域内常量的验证规则。\nTitle 类型公开的 API 允许我们以 有效状态 构建它，因为给定的 NewTitle 工厂函数会检查传入属性的有效性。\n将验证规则与值类型耦合的主要好处是代码库更易于维护。\n事实上，不会再有重复的验证逻辑，因为我们将不断重复使用值类型的代码。例如，在解码 JSON 请求内容时：\ntype addTabReq struct { Title tab.Title `json:\"tab_title\"` } func (r *addTabReq) UnmarshalJSON(data []byte) error { type clone addTabReq var req clone if err := json.Unmarshal(data, \u0026req); err != nil { return err } var err error if r.Title, err = tab.NewTitle(req.Title.String()); err != nil { return err } return nil } 值类型还公开了一个 Equals 方法，以确保使用它包含的所有字段而不是内存地址进行与其他值的比较，从而减少值比较的错误和代码重复。\n注意：在标题示例中只有一个字段，但一个值类型也可以由多个字段组成并表示为一个结构体。值类型被设计为不可变；这就是 Title 类型在方法上只有接收入参的原因。\n为了让人们理解为值类型选择不可变设计的原因，我们以数字 0 为例。\n0 是不可变的；即使当数学运算将一个数字添加到 0 时，它不会改变 0 仍然是 0 的事实。\n出于同样的原因，值类型不会改变。它所代表的东西是独一无二的。\n在设计理念上，拥有不可变值类型更安全。\n当使用值类型作为模型的字段时，不可变设计使其免受由于可变共享状态引起的副作用的影响，这是常见的错误来源，尤其是在 Go 等并发编程语言中。\n|放在哪里 我将值类型文件放在拥有值类型实现的包中，因为这些不应该在包之间共享。\n📂 app ┗ 📦tab ┣ 📜 tab.go ┗ 📜 title.go 有时在不同的包中重用它们可能是有意义的，主要是当值类型表示非常通用的规则时（例如电子邮件）。但是你需要决定是否保持包解耦。\n提示：有一句关于这个的 Go 谚语，你可能需要考虑一点复制比一点依赖要好# 实体、聚合和聚合根 这些模式是相似的，这种相似性在第一次使用它们时会导致一些混淆。\n即使相似，它们也有明确和不同的用例，它们的用法可以结合起来以实现最佳模型设计。\n实体 实体是一种域类型，它不是由其属性定义的，而是由其标识符定义的。\npackage tab import ( \"time\" ) // Tab represents a tab type Tab struct { ID ID Title Title Description Description Icon Icon Link Link Created time.Time Updated time.Time } // New returns a tab created for the first time func New(id ID, title Title, description Description, icon Icon, link Link) *Tab { return \u0026Tab{ ID: id, Title: title, Description: description, Icon: icon, Link: link, Created: time.Now(), } } // Update updates a tab with new attributes func (t *Tab) Update(title Title, description Description, icon Icon, link Link) { t.Title = title t.Description = description t.Icon = icon t.Link = link t.Updated = time.Now() } ｜实体设计选择和优势 乍一看，实体可能看起来像是由更多字段组成的值类型，但实体和值类型之间的主要区别与身份的概念有关。实体具有标识（在 Tab 示例中为 ID ），相反，值类型没有标识，因为它表示值的标识符。\n拥有身份意味着一种类型可以随着时间的推移而改变并仍然表示相同的原始类型，这一愿景导致了实体应该被设计为可变类型的结论，并且从代码的角度来看，这导致我们需要使用指针传递变量。\n实体是核心领域组件，需要确保它们所代表的领域概念的有效性。\n例如，考虑 Tab 的 New 工厂函数和 Update 方法。这些 API 将处理 Tab 的创建和更新，而不需要传递 time.Time 值，因为类型本身需要保证其正确性。\n为了更容易地保护常量并传播领域中无处不在的语言的使用，实体应该使用值类型作为构建块。 注意：Tab 结构中的 Created 和 Updated 字段使用内置值类型  time.Time，因为按照设计它是不可变的并且表示域的时间聚合体 聚合体是一组粘合在一起并被视为单个工作单元的域类型。一个聚合体也可能包含更多的聚合体。\n使用文章开头分享的域描述，可以将集合用作聚合体：\npackage collection import ( \"collection/tab\" \"time\" ) // Collection represent a collection type Collection struct { ID ID Name Name Tabs []*tab.Tab Created time.Time Updated time.Time } // New returns a collection created for the first time func New(id ID, name Name) *Collection { return \u0026Collection{ ID: id, Name: name, Tabs: make([]*tab.Tab, 0), Created: time.Now(), } } // Rename renames a collection func (c *Collection) Rename(name Name) { c.Name = name c.Updated = time.Now() } // AddTabs adds tabs to the collection func (c *Collection) AddTabs(tabs ...*tab.Tab) { c.Tabs = append(c.Tabs, tabs...) c.Updated = time.Now() } // RemoveTab removes a tab if it exists func (c *Collection) RemoveTab(id tab.ID) bool { for i, t := range c.Tabs { if t.ID == id { c.Tabs[i] = c.Tabs[len(c.Tabs)-1] c.Tabs[len(c.Tabs)-1] = nil c.Tabs = c.Tabs[:len(c.Tabs)-1] c.Updated = time.Now() return true } } return false } // FindTab returns a tab if it exists func (c *Collection) FindTab(id tab.ID) (*tab.Tab, bool) { for _, t := range c.Tabs { if t.ID == id { return t, true } } return nil, false } // UpdateTab updates a tab if it exists func (c *Collection) UpdateTab(t *tab.Tab) bool { for i, tb := range c.Tabs { if tb.ID == t.ID { c.Tabs[i] = t c.Updated = time.Now() return true } } return false } ｜聚合设计选择和优势 聚合共享实体的相同设计选择；它是可变的，它有一个身份，并使用域值类型作为构建块。 它还使用为所包含的类型定义的无处不在的语言，并丰富了它，增加了它的一种。\n实体和聚合的区别在于它可以是更多域类型的集群，也可以组合更多的聚合。\n聚合根 聚合根表示与聚合相同的概念，唯一不同的是：它表示可用于在域用例中进行交互的聚合根。\n这意味着，以极其简化的方式，聚合根拥有用于从数据库中检索它的标识符。\n至于聚合，可以根据域将实体用作聚合根。\n在文章开头共享的域中，Workspace 就是聚合根：\npackage workspace import ( \"time\" \"workspace/collection\" \"workspace/collection/tab\" ) // Workspace represent a workspace type Workspace struct { ID ID Name Name CustomerID CustomerID Collections []*collection.Collection Created time.Time Updated time.Time } // New returns a workspace created for the first time func New(id ID, name Name, customerID CustomerID) *Workspace { return \u0026Workspace{ ID: id, Name: name, CustomerID: customerID, Collections: make([]*collection.Collection, 0), Created: time.Now(), } } // Rename change the name of a workspace func (w *Workspace) Rename(name Name) { w.Name = name w.Updated = time.Now() } // AddCollections add a collection func (w *Workspace) AddCollections(collections ...*collection.Collection) { w.Collections = append(w.Collections, collections...) w.Updated = time.Now() } // RemoveCollection removes a collection if it exists func (w *Workspace) RemoveCollection(id collection.ID) bool { for i, coll := range w.Collections { if coll.ID == id { w.Collections[i] = w.Collections[len(w.Collections)-1] w.Collections[len(w.Collections)-1] = nil w.Collections = w.Collections[:len(w.Collections)-1] w.Updated = time.Now() return true } } return false } // RenameCollection renames a collection if it exists func (w *Workspace) RenameCollection(id collection.ID, name collection.Name) bool { for _, coll := range w.Collections { if coll.ID == id { coll.Rename(name) w.Updated = time.Now() return true } } return false } |放置它们的位置 在将领域表示为代码时，这三种模式是最重要的，因为它们是它的组成部分，所有的特征和不变量都围绕着它们。\n由于这些非常重要，因此值得拥有自己的包，作为所有依赖于它们的领域类型的入口点。\n📂 app ┗ 📦workspace ┣ 📜id.go ┣ 📜name.go ┣ 📜workspace.go ┣ 📜 ... ┗ 📦collection ┣ 📜id.go ┣ 📜name.go ┣ 📜collection.go ┣ 📜 ... ┗ 📦tab ┣ 📜id.go ┣ 📜title.go ┣ 📜description.go ┣ 📜 ... ┗ 📜tab.go 在这个结构中，我将三者分开，因为作为集合的选项卡不需要它们的父项来存在和定义。而且，最重要的是，如果只需要一种，将它们拆分到不同的包中可以不导入所有域类型。\n存储库 存储库模式可能是 DDD 世界中最著名的。\n这种模式代表了一种机制，用于将域类型与持久性进行映射，公开模拟与内存切片交互的 API。\n我通常将其表示为如下所示的接口：\npackage tab import \"errors\" var( //Errors returned by the repository ErrRepoNextID = errors.New(\"tab: could not return next id\") ErrRepoList = errors.New(\"tab: could not list\") ErrNotFound = errors.New(\"tab: could not find\") ErrRepoGet = errors.New(\"tab: could not get\") ErrRepoAdd = errors.New(\"tab: could not add\") ErrRepoRemove = errors.New(\"tab: could not remove\") ) type Repo interface { // NextID returns the next free ID and an error in case of failure NextID() (ID, error) // List returns a tab slice and an error in case of failure List() ([]*Tab, error) // Find returns a tab or nil if it is not found and an error in case of failure Find(ID) (*Tab, error) // Get returns a tab and error in case is not found or failure Get(ID) (*Tab, error) // Add persists a tab (already existing or not) and returns an error in case of failure Add(*Tab) error // Remove removes a tab and returns and error in case is not found or failure Remove(ID) error } 如果应用有读写分离的操作，可以这样表示：\npackage tab // ... type ReadRepo interface { // List returns a tab slice and an error in case of failure  List() ([]*Tab, error) // Find returns a tab or nil if it is not found and an error in case of failure  Find(ID) (*Tab, error) // Get returns a tab and error in case is not found or failure  Get(ID) (*Tab, error) } type WriteRepo interface { // NextID returns the next free ID and an error in case of failure  NextID() (ID, error) // Add persists a tab (already existing or not) and returns an error in case of failure  Add(*Tab) error // Remove removes a tab and returns and error in case is not found or failure  Remove(ID) error } ｜存储库设计选择和优势 从设计和技术的角度来看，存储库模式提供了多种优势。\n采用这种模式允许将应用程序与特定数据库（例如 MySQL、MongoDB 或 Google Spanner ）解耦，这些好处会在测试期间出现，因为可以编写内存存储库实现，以及在迁移到不同数据库期间。\n迁移应用程序以使用不同的数据库一直是一项昂贵的操作，但使用这种模式可以降低成本，因为只需要创建或更新一个存储库实现即可使用新数据库，并且存储库接口可以避免更新整个代码库。\n为了便于迁移，将存储库及其报错定义放在同一个包中也是必不可少的，因此，即使对于错误检查，也只有拥有存储库接口的包与整个应用程序耦合。\n是否可以在需要时从包含存储库实现的包中丰富已经指定的存储库错误：\nfunc (r *MysqlRepo) Add(t *Tab) error { // ... return fmt.Errorf(\"%w: %s\", tab.ErrRepoAdd, \"a more detailed reason here\") } 从设计的角度来看，应用存储库模式有助于定义上下文的清晰边界，并使其与不相关的子域分离，因为它的 API 主要（但不仅限于）使用聚合根及其 ID 。\n存储库模式 API 还强制使用和建立通用语言，例如，可以在读取操作中使用过滤器参数并为该需求指定更具体的 API。\n在需要过滤的地方，大多数时候，可以声明一个使用泛在语言的专用函数，减少认知负担和应用程序的复杂性。\n// Don't repo.List(repo.Filter{\"active\": true}) // Do repo.ListActive() |放在哪里 与往常一样，我确实将有关存储库接口的文件放在拥有聚合的包中。\n但是有关实现的文件，例如要对 MySQL 数据库执行查询的文件，我通常将它放在内部目录中，因为这些文件与应用程序高度耦合，不应在不同地方重复使用。\n📂 app ┣ 📦internal ┃ ┗ 📦tab ┃ ┗ 📜repo.go // here a MySQL implementation ┗ 📦tab ┗ 📜repo.go // here a the interface and the errors 结论 将 DDD 方法应用于代码时，战术设计是 101，但重要的是不要强迫语言遵循不适合它的习惯用法。在不使用 DTO、始终有效的对象 或其他源自面向对象世界的模式的情况下，也可以达到相同的目标。\n这与 Golang 中的战略设计方法相结合，可为你提供清晰且最小的 DDD 代码库。\n你不同意我和我的设计方法吗？请随时在下面的评论中分享你在 Go 中开发代码库时所做的主要决定！\n注意：本文是关于 DDD 和 Golang 的系列文章的一部分，如果你有兴趣了解有关特定主题的更多信息，请告诉我！\n","wordCount":"1593","inLanguage":"en","datePublished":"2021-11-13T16:17:21+08:00","dateModified":"2021-11-13T16:17:21+08:00","author":{"@type":"Person","name":"Damiano Petrungaro"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.ax4j.com/posts/ddd-using-golang-tactical-design/"},"publisher":{"@type":"Organization","name":"ax for swartz","logo":{"@type":"ImageObject","url":"https://www.ax4j.com/%3Clink%20/%20abs%20url%3E"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://www.ax4j.com/ accesskey=h title="Home (Alt + H)">
<img src=/imgs/td_pixel_64.png alt=logo aria-label=logo height=35>Home</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://www.ax4j.com/tags/ title=Tags>
<span>Tags</span>
</a>
</li>
<li>
<a href=https://www.ax4j.com/resources/ title=Resources>
<span>Resources</span>
</a>
</li>
<li>
<a href=https://www.ax4j.com/about/ title=About>
<span>About</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<h1 class=post-title>
Golang 中的领域驱动设计 - 战术设计
</h1>
<div class=post-meta><span title="2021-11-13 16:17:21 +0800 CST">2021-11-13 16:17:21 +0800</span>&nbsp;·&nbsp;24 min&nbsp;·&nbsp;1593 words&nbsp;·&nbsp;Damiano Petrungaro
</div>
</header>
<div class=post-content><blockquote>
<p>译自 <a href=/https://www.damianopetrungaro.com/posts/ddd-using-golang-tactical-design/>Domain Driven Design in Golang - Tactical Design</a> - by - <a href=https://www.damianopetrungaro.com/>Damiano Petrungaro</a></p>
</blockquote>
<p>在过去的几周里，我收到了很多关于我写的 Golang 和领域驱动设计系列的第一篇文章的私下和公开的问题。</p>
<p>我私下收到的大多数问题都是关于如何使用 DDD 战术模式编写整个 Golang 项目（或一般代码）。</p>
<p>所以我决定解决其中的一些问题，我将更广泛地解释我对 Golang 和 DDD 的看法，描述我使用的一些代码模式和我一直考虑的权衡。</p>
<h2 id=战术设计>战术设计<a hidden class=anchor aria-hidden=true href=#战术设计>#</a></h2>
<p>在开始之前，我认为必须定义什么是战术设计。</p>
<p>战术设计描述了一组模式，用于将领域分析中定义的常量和模型转化为代码，通常由战略设计驱动。应用这些模式的最终目标是以简单但富有表现力和安全的方式对代码进行建模。</p>
<p>战术模式在 <code>PHP</code>、<code>Java</code> 和 <code>C#</code> 等语言社区中广为人知，因为当今可用的有关 <code>DDD</code> 模式的资源大多是面向对象的，但这并不意味着将这些概念应用到有不同范式的语言中是困难或错误的。</p>
<p>我将在本文中介绍最著名和最常用的例子：</p>
<ul>
<li>值对象（或值类型）</li>
<li>实体、聚合和聚合根</li>
<li>存储库</li>
</ul>
<p>在一一描述源自 <code>DDD</code> 文献的所有模式之前，我想换个方向。</p>
<p>我将从 <em>始终有效的状态</em> 这一概念开始，因为它会影响编写代码的方式。</p>
<h2 id=始终有效的状态>始终有效的状态<a hidden class=anchor aria-hidden=true href=#始终有效的状态>#</a></h2>
<p>关于 <em>始终有效的状态</em> 的想法是，当一个类型不符合其上下文的常量时，不应创建该类型。</p>
<p>有很多方法可以实现这个目标：添加一个验证 <code>HTTP</code> 的中间件，创建一个验证 <code>CLI</code> 输入的函数，或者将验证与保护常量的类型结合起来。</p>
<p>每种方式都有它的好处和坏处；我们有责任评估这些选项并为我们的场景选择最好的，同时考虑定义这些规则的编程语言。</p>
<p>谈到这些是因为，在 Golang 中，没有办法阻止在无效状态下创建类型。</p>
<blockquote>
<p>无法实现的始终有效状态</p>
</blockquote>
<p>让我们快速定义一个领域，并将其主要组件建模为代码。</p>
<hr>
<p>XYZ 是一款帮助你整理浏览器标签和书签的产品，能够与你常打开的标签进行交互。它允许客户创建书签集合并在工作区中共享这些集合，从而为每个工作区创建简单、分类和专业化的用户体验。</p>
<hr>
<p>该领域内容都是关于标签和书签的。</p>
<p>在分析过程中定义了我们领域的通用语言之后，我们需要编码的元素之一是选项卡的标题。</p>
<p>标题 必须 是 1 到 50 个字符之间的字符串，并且 不能为空。</p>
<p>选项卡及其标题可以这样编码：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// tab/tab.go
</span><span style=color:#75715e></span><span style=color:#f92672>package</span> <span style=color:#a6e22e>tab</span>
<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Tab</span> <span style=color:#66d9ef>struct</span> {
    <span style=color:#a6e22e>Title</span> <span style=color:#66d9ef>string</span>
}

<span style=color:#75715e>// cmd/app/main.go
</span><span style=color:#75715e></span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
<span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;tab&#34;</span>
<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#a6e22e>t</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>Tab</span>{<span style=color:#a6e22e>Title</span>:<span style=color:#e6db74>&#34;&#34;</span>}
    <span style=color:#75715e>// ...
</span><span style=color:#75715e></span>}
</code></pre></div><p>在第一次迭代中，只需要几行代码，非常简洁！</p>
<p>但是在 <code>main.go</code> 文件中刚刚创建了一个标题为空的 <code>Tab</code>；这种情况不应该发生在我们的领域，因为存在需要保护的常量。</p>
<p>我们需要解决它。</p>
<p>可以通过添加一些验证规则来保护领域内的字段：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// tab/tab.go
</span><span style=color:#75715e></span><span style=color:#f92672>package</span> <span style=color:#a6e22e>tab</span>
<span style=color:#f92672>import</span> (
	<span style=color:#e6db74>&#34;errors&#34;</span>
)
<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Tab</span> <span style=color:#66d9ef>struct</span> {
    <span style=color:#a6e22e>Title</span> <span style=color:#66d9ef>string</span>
}
<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>New</span>(<span style=color:#a6e22e>t</span> <span style=color:#66d9ef>string</span>) (<span style=color:#f92672>*</span><span style=color:#a6e22e>Tab</span>, <span style=color:#66d9ef>error</span>) {
	<span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>l</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>t</span>); {
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>l</span> &lt; <span style=color:#ae81ff>1</span>:
		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>New</span>(<span style=color:#e6db74>&#34;tab: could not use title less than 1 char&#34;</span>)
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>l</span> &gt; <span style=color:#ae81ff>50</span>:
		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>New</span>(<span style=color:#e6db74>&#34;tab: could not use title more than 50 char&#34;</span>)
	<span style=color:#66d9ef>default</span>:
		<span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>Tab</span>{<span style=color:#a6e22e>Title</span>:<span style=color:#a6e22e>t</span>}, <span style=color:#66d9ef>nil</span>
	}
}

<span style=color:#75715e>// cmd/app/main.go
</span><span style=color:#75715e></span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
<span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;tab&#34;</span>
<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>Tab</span>.<span style=color:#a6e22e>New</span>(<span style=color:#e6db74>&#34;a valid title&#34;</span>)
    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
        panic(<span style=color:#a6e22e>err</span>)
    }
    <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Title</span> = <span style=color:#e6db74>&#34;&#34;</span>
    <span style=color:#75715e>// ...
</span><span style=color:#75715e></span>}
</code></pre></div><p>现在似乎比以前好多了；保护领域的验证规则位于新的生成函数中。</p>
<p>但同样，我们仍然能够使标题这一字段无效，因为 <code>Go</code> 提供的关于是否对外暴露、外部包访问的语言机制允许这样做。</p>
<p>这可以防止 <code>Tab</code> 结构体的字段对外暴露，因为引用它的包无法访问这些私有字段：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// tab/tab.go
</span><span style=color:#75715e></span><span style=color:#f92672>package</span> <span style=color:#a6e22e>tab</span>
<span style=color:#f92672>import</span> (
	<span style=color:#e6db74>&#34;errors&#34;</span>
)
<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Tab</span> <span style=color:#66d9ef>struct</span> {
    <span style=color:#a6e22e>title</span> <span style=color:#66d9ef>string</span>
}
<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>New</span>(<span style=color:#a6e22e>t</span> <span style=color:#66d9ef>string</span>) (<span style=color:#f92672>*</span><span style=color:#a6e22e>Tab</span>, <span style=color:#66d9ef>error</span>) {
	<span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>l</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>t</span>); {
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>l</span> &lt; <span style=color:#ae81ff>1</span>:
		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>New</span>(<span style=color:#e6db74>&#34;tab: could not use title less than 1 char&#34;</span>)
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>l</span> &gt; <span style=color:#ae81ff>50</span>:
		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>New</span>(<span style=color:#e6db74>&#34;tab: could not use title more than 50 char&#34;</span>)
	<span style=color:#66d9ef>default</span>:
		<span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>Tab</span>{<span style=color:#a6e22e>title</span>:<span style=color:#a6e22e>t</span>}, <span style=color:#66d9ef>nil</span>
	}
}

<span style=color:#75715e>// cmd/app/main.go
</span><span style=color:#75715e></span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
<span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;tab&#34;</span>
<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>tab</span>.<span style=color:#a6e22e>New</span>(<span style=color:#e6db74>&#34;a valid title&#34;</span>)
    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
        panic(<span style=color:#a6e22e>err</span>)
    }
    <span style=color:#a6e22e>t2</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>tab</span>.<span style=color:#a6e22e>Tab</span>{}
    <span style=color:#75715e>// ...
</span><span style=color:#75715e></span>}
</code></pre></div><p>最终创建了一个有效的 <code>Title</code> 并将其分配给变量 <code>t</code>，显然我们不能再更改它了。</p>
<p>但是 <code>t2</code> 处于无效状态，它没有标题，或者更准确地说，它具有字符串类型的零值。</p>
<p>每次在应用程序的任何函数中给出 <code>Title</code> 类型的零值时，可能会更加防御并返回错误。</p>
<p>你可能已经注意到，由于 <code>Golang</code> 的机制，无法通过设计在 <code>Golang</code> 中实现始终有效的状态。</p>
<p>与其自掘坟墓试图实现无法实现的目标，不如从不同的角度来解决这个问题。</p>
<blockquote>
<p>寻找平衡</p>
</blockquote>
<p>作为一名工程师，我日常工作的一部分是评估权衡，尽可能减少领域类型的安全问题和替代方案可能带来的简单性之间的技术债务平衡。</p>
<p>我从 <code>Golang</code> 社区接受的理念之一是 <code>API</code> 包设计；设计一个包时应该考虑到用户将要使用它的用途。</p>
<p>这种哲学选择是用于类型设计和实现战术模式的完美平衡。</p>
<p>我应用这一理念，公开与包安全交互所需的 API，并授权用户决定它的使用，这意味着如果用户不使用包。</p>
<p>无论如何，在某些情况下，更严格地围绕包的 API 采取行动是有意义的，尤其是在公司环境中。</p>
<p>例如，在一个不停地推送特性的团队中，很难跟踪所有的变化，在一些包中添加更多的保护有助于尊重域不变量，减少错误的数量。</p>
<p>但在添加防御性代码之前，必须明确这一需求，衡量由于缺乏保护而导致的错误、中断和事件的数量，因为这些额外的防御性方法会增加复杂性。</p>
<p><em>注意：Google 定义了一种很好的方法，你可以扩展并使用它来跟踪这些事件，有关 <a href=https://landing.google.com/sre/>SRE</a> 的更多信息。</em></p>
<h2 id=如何用-golang-实现战术设计模式>如何用 Golang 实现战术设计模式<a hidden class=anchor aria-hidden=true href=#如何用-golang-实现战术设计模式>#</a></h2>
<p>从现在开始我的主要目标是实现 <code>DDD</code> 模式而不陷入 <code>OOP</code> 陷阱，并利用语言机制来减少 <code>API</code> 和 <code>package</code> 耦合。</p>
<h4 id=-值对象或值类型># 值对象（或值类型）<a hidden class=anchor aria-hidden=true href=#-值对象或值类型>#</a></h4>
<p>我确实在 <code>Golang</code> 中将它们称为值类型，因为在这种语言中，没有 <code>对象</code> 的概念；<code>对象</code> 这个词可能误导你去思考面向对象。</p>
<p>值类型是 DDD 文献中描述的一种模式，用于将相关事物分组为一个不可变单元，可通过组成它的属性进行比较。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>tab</span>
<span style=color:#f92672>import</span> (
	<span style=color:#e6db74>&#34;errors&#34;</span>
	<span style=color:#e6db74>&#34;fmt&#34;</span>
	<span style=color:#e6db74>&#34;strings&#34;</span>
)
<span style=color:#66d9ef>const</span> (
	<span style=color:#a6e22e>minTitleLength</span> = <span style=color:#ae81ff>1</span>
	<span style=color:#a6e22e>maxTitleLength</span> = <span style=color:#ae81ff>50</span>
)
<span style=color:#66d9ef>var</span> (
	<span style=color:#75715e>// Errors used when an invalid title is given
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>ErrInvalidTitle</span>  = <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>New</span>(<span style=color:#e6db74>&#34;tab: could not use invalid title&#34;</span>)
	<span style=color:#a6e22e>ErrTitleTooShort</span> = <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;%w: min length allowed is %d&#34;</span>, <span style=color:#a6e22e>ErrInvalidTitle</span>, <span style=color:#a6e22e>minTitleLength</span>)
	<span style=color:#a6e22e>ErrTitleTooLong</span>  = <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;%w: max length allowed is %d&#34;</span>, <span style=color:#a6e22e>ErrInvalidTitle</span>, <span style=color:#a6e22e>maxTitleLength</span>)
)

<span style=color:#75715e>// Title represents a tab title
</span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Title</span> <span style=color:#66d9ef>string</span>

<span style=color:#75715e>// NewTitle returns a title and an error back
</span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>NewTitle</span>(<span style=color:#a6e22e>d</span> <span style=color:#66d9ef>string</span>) (<span style=color:#a6e22e>Title</span>, <span style=color:#66d9ef>error</span>) {
	<span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>l</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>strings</span>.<span style=color:#a6e22e>TrimSpace</span>(<span style=color:#a6e22e>d</span>)); {
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>l</span> &lt; <span style=color:#a6e22e>minTitleLength</span>:
		<span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;&#34;</span>, <span style=color:#a6e22e>ErrTitleTooShort</span>
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>l</span> &gt; <span style=color:#a6e22e>maxTitleLength</span>:
		<span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;&#34;</span>, <span style=color:#a6e22e>ErrTitleTooLong</span>
	<span style=color:#66d9ef>default</span>:
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Title</span>(<span style=color:#a6e22e>d</span>), <span style=color:#66d9ef>nil</span>
	}
}

<span style=color:#75715e>// String returns a string representation of the title
</span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>t</span> <span style=color:#a6e22e>Title</span>) <span style=color:#a6e22e>String</span>() <span style=color:#66d9ef>string</span> {
	<span style=color:#66d9ef>return</span> string(<span style=color:#a6e22e>t</span>)
}

<span style=color:#75715e>// Equals returns true if the titles are equal
</span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>t</span> <span style=color:#a6e22e>Title</span>) <span style=color:#a6e22e>Equals</span>(<span style=color:#a6e22e>t2</span> <span style=color:#a6e22e>Title</span>) <span style=color:#66d9ef>bool</span> {
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>String</span>() <span style=color:#f92672>==</span> <span style=color:#a6e22e>t2</span>.<span style=color:#a6e22e>String</span>()
}
</code></pre></div><h4 id=值类型设计选择和优势>|值类型设计选择和优势<a hidden class=anchor aria-hidden=true href=#值类型设计选择和优势>#</a></h4>
<p>值类型有利于将域中的概念表示为代码，具有领域内常量的验证规则。</p>
<p><code>Title</code> 类型公开的 <code>API</code> 允许我们以 有效状态 构建它，因为给定的 <code>NewTitle</code> 工厂函数会检查传入属性的有效性。</p>
<p>将验证规则与值类型耦合的主要好处是代码库更易于维护。</p>
<p>事实上，不会再有重复的验证逻辑，因为我们将不断重复使用值类型的代码。例如，在解码 <code>JSON</code> 请求内容时：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>addTabReq</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>Title</span> <span style=color:#a6e22e>tab</span>.<span style=color:#a6e22e>Title</span> <span style=color:#e6db74>`json:&#34;tab_title&#34;`</span>
}
<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>addTabReq</span>) <span style=color:#a6e22e>UnmarshalJSON</span>(<span style=color:#a6e22e>data</span> []<span style=color:#66d9ef>byte</span>) <span style=color:#66d9ef>error</span> {
	<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>clone</span> <span style=color:#a6e22e>addTabReq</span>
	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>req</span> <span style=color:#a6e22e>clone</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>json</span>.<span style=color:#a6e22e>Unmarshal</span>(<span style=color:#a6e22e>data</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>req</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
	}
	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>err</span> <span style=color:#66d9ef>error</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>Title</span>, <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>tab</span>.<span style=color:#a6e22e>NewTitle</span>(<span style=color:#a6e22e>req</span>.<span style=color:#a6e22e>Title</span>.<span style=color:#a6e22e>String</span>()); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
	}
    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
}
</code></pre></div><p>值类型还公开了一个 <code>Equals</code> 方法，以确保使用它包含的所有字段而不是内存地址进行与其他值的比较，从而减少值比较的错误和代码重复。</p>
<p>注意：在标题示例中只有一个字段，但一个值类型也可以由多个字段组成并表示为一个结构体。</p>
<p>值类型被设计为不可变；这就是 <code>Title</code> 类型在方法上只有接收入参的原因。</p>
<p>为了让人们理解为值类型选择不可变设计的原因，我们以数字 <code>0</code> 为例。</p>
<p><code>0</code> 是不可变的；即使当数学运算将一个数字添加到 <code>0</code> 时，它不会改变 <code>0</code> 仍然是 <code>0</code> 的事实。</p>
<p>出于同样的原因，值类型不会改变。它所代表的东西是独一无二的。</p>
<p>在设计理念上，拥有不可变值类型更安全。</p>
<p>当使用值类型作为模型的字段时，不可变设计使其免受由于可变共享状态引起的副作用的影响，这是常见的错误来源，尤其是在 <code>Go</code> 等并发编程语言中。</p>
<h4 id=放在哪里>|放在哪里<a hidden class=anchor aria-hidden=true href=#放在哪里>#</a></h4>
<p>我将值类型文件放在拥有值类型实现的包中，因为这些不应该在包之间共享。</p>
<pre tabindex=0><code>📂 app
 ┗ 📦tab
   ┣ 📜 tab.go
   ┗ 📜 title.go
</code></pre><p>有时在不同的包中重用它们可能是有意义的，主要是当值类型表示非常通用的规则时（例如电子邮件）。但是你需要决定是否保持包解耦。</p>
<p>提示：有一句关于这个的 Go 谚语，你可能需要考虑一点复制比一点依赖要好</p>
<h4 id=-实体聚合和聚合根># 实体、聚合和聚合根<a hidden class=anchor aria-hidden=true href=#-实体聚合和聚合根>#</a></h4>
<p>这些模式是相似的，这种相似性在第一次使用它们时会导致一些混淆。</p>
<p>即使相似，它们也有明确和不同的用例，它们的用法可以结合起来以实现最佳模型设计。</p>
<h5 id=实体>实体<a hidden class=anchor aria-hidden=true href=#实体>#</a></h5>
<p>实体是一种域类型，它不是由其属性定义的，而是由其标识符定义的。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>tab</span>
<span style=color:#f92672>import</span> (
	<span style=color:#e6db74>&#34;time&#34;</span>
)
<span style=color:#75715e>// Tab represents a tab
</span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Tab</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>ID</span>          <span style=color:#a6e22e>ID</span>
	<span style=color:#a6e22e>Title</span>       <span style=color:#a6e22e>Title</span>
	<span style=color:#a6e22e>Description</span> <span style=color:#a6e22e>Description</span>
	<span style=color:#a6e22e>Icon</span>        <span style=color:#a6e22e>Icon</span>
	<span style=color:#a6e22e>Link</span>        <span style=color:#a6e22e>Link</span>
	<span style=color:#a6e22e>Created</span>     <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Time</span>
	<span style=color:#a6e22e>Updated</span>     <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Time</span>
}

<span style=color:#75715e>// New returns a tab created for the first time
</span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>New</span>(<span style=color:#a6e22e>id</span> <span style=color:#a6e22e>ID</span>, <span style=color:#a6e22e>title</span> <span style=color:#a6e22e>Title</span>, <span style=color:#a6e22e>description</span> <span style=color:#a6e22e>Description</span>, <span style=color:#a6e22e>icon</span> <span style=color:#a6e22e>Icon</span>, <span style=color:#a6e22e>link</span> <span style=color:#a6e22e>Link</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>Tab</span> {
	<span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>Tab</span>{
		<span style=color:#a6e22e>ID</span>:          <span style=color:#a6e22e>id</span>,
		<span style=color:#a6e22e>Title</span>:       <span style=color:#a6e22e>title</span>,
		<span style=color:#a6e22e>Description</span>: <span style=color:#a6e22e>description</span>,
		<span style=color:#a6e22e>Icon</span>:        <span style=color:#a6e22e>icon</span>,
		<span style=color:#a6e22e>Link</span>:        <span style=color:#a6e22e>link</span>,
		<span style=color:#a6e22e>Created</span>:     <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Now</span>(),
	}
}
<span style=color:#75715e>// Update updates a tab with new attributes
</span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Tab</span>) <span style=color:#a6e22e>Update</span>(<span style=color:#a6e22e>title</span> <span style=color:#a6e22e>Title</span>, <span style=color:#a6e22e>description</span> <span style=color:#a6e22e>Description</span>, <span style=color:#a6e22e>icon</span> <span style=color:#a6e22e>Icon</span>, <span style=color:#a6e22e>link</span> <span style=color:#a6e22e>Link</span>) {
	<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Title</span> = <span style=color:#a6e22e>title</span>
	<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Description</span> = <span style=color:#a6e22e>description</span>
	<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Icon</span> = <span style=color:#a6e22e>icon</span>
	<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Link</span> = <span style=color:#a6e22e>link</span>
	<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Updated</span> = <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Now</span>()
}

</code></pre></div><h5 id=实体设计选择和优势>｜实体设计选择和优势<a hidden class=anchor aria-hidden=true href=#实体设计选择和优势>#</a></h5>
<p>乍一看，实体可能看起来像是由更多字段组成的值类型，但实体和值类型之间的主要区别与身份的概念有关。实体具有标识（在 <code>Tab</code> 示例中为 <code>ID</code> ），相反，值类型没有标识，因为它表示值的标识符。</p>
<p>拥有身份意味着一种类型可以随着时间的推移而改变并仍然表示相同的原始类型，这一愿景导致了实体应该被设计为可变类型的结论，并且从代码的角度来看，这导致我们需要使用指针传递变量。</p>
<p>实体是核心领域组件，需要确保它们所代表的领域概念的有效性。</p>
<p>例如，考虑 <code>Tab</code> 的 <code>New</code> 工厂函数和 <code>Update</code> 方法。这些 <code>API</code> 将处理 <code>Tab</code> 的创建和更新，而不需要传递 <code>time.Time</code> 值，因为类型本身需要保证其正确性。</p>
<p>为了更容易地保护常量并传播领域中无处不在的语言的使用，实体应该使用值类型作为构建块。 注意：<code>Tab</code> 结构中的 <code>Created</code> 和 <code>Updated</code> 字段使用内置值类型 <code> time.Time</code>，因为按照设计它是不可变的并且表示域的时间</p>
<h5 id=聚合体>聚合体<a hidden class=anchor aria-hidden=true href=#聚合体>#</a></h5>
<p>聚合体是一组粘合在一起并被视为单个工作单元的域类型。一个聚合体也可能包含更多的聚合体。</p>
<p>使用文章开头分享的域描述，可以将集合用作聚合体：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>collection</span>
<span style=color:#f92672>import</span> (
	<span style=color:#e6db74>&#34;collection/tab&#34;</span>
	<span style=color:#e6db74>&#34;time&#34;</span>
)
<span style=color:#75715e>// Collection represent a collection
</span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Collection</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>ID</span>      <span style=color:#a6e22e>ID</span>
	<span style=color:#a6e22e>Name</span>    <span style=color:#a6e22e>Name</span>
	<span style=color:#a6e22e>Tabs</span>    []<span style=color:#f92672>*</span><span style=color:#a6e22e>tab</span>.<span style=color:#a6e22e>Tab</span>
	<span style=color:#a6e22e>Created</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Time</span>
	<span style=color:#a6e22e>Updated</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Time</span>
}
<span style=color:#75715e>// New returns a collection created for the first time
</span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>New</span>(<span style=color:#a6e22e>id</span> <span style=color:#a6e22e>ID</span>, <span style=color:#a6e22e>name</span> <span style=color:#a6e22e>Name</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>Collection</span> {
	<span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>Collection</span>{
		<span style=color:#a6e22e>ID</span>:      <span style=color:#a6e22e>id</span>,
		<span style=color:#a6e22e>Name</span>:    <span style=color:#a6e22e>name</span>,
		<span style=color:#a6e22e>Tabs</span>:    make([]<span style=color:#f92672>*</span><span style=color:#a6e22e>tab</span>.<span style=color:#a6e22e>Tab</span>, <span style=color:#ae81ff>0</span>),
		<span style=color:#a6e22e>Created</span>: <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Now</span>(),
	}
}
<span style=color:#75715e>// Rename renames a collection
</span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Collection</span>) <span style=color:#a6e22e>Rename</span>(<span style=color:#a6e22e>name</span> <span style=color:#a6e22e>Name</span>) {
	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>Name</span> = <span style=color:#a6e22e>name</span>
	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>Updated</span> = <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Now</span>()
}
<span style=color:#75715e>// AddTabs adds tabs to the collection
</span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Collection</span>) <span style=color:#a6e22e>AddTabs</span>(<span style=color:#a6e22e>tabs</span> <span style=color:#f92672>...*</span><span style=color:#a6e22e>tab</span>.<span style=color:#a6e22e>Tab</span>) {
	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>Tabs</span> = append(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>Tabs</span>, <span style=color:#a6e22e>tabs</span><span style=color:#f92672>...</span>)
	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>Updated</span> = <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Now</span>()
}
<span style=color:#75715e>// RemoveTab removes a tab if it exists
</span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Collection</span>) <span style=color:#a6e22e>RemoveTab</span>(<span style=color:#a6e22e>id</span> <span style=color:#a6e22e>tab</span>.<span style=color:#a6e22e>ID</span>) <span style=color:#66d9ef>bool</span> {
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>t</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>Tabs</span> {
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>ID</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>id</span> {
			<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>Tabs</span>[<span style=color:#a6e22e>i</span>] = <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>Tabs</span>[len(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>Tabs</span>)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
			<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>Tabs</span>[len(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>Tabs</span>)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] = <span style=color:#66d9ef>nil</span>
			<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>Tabs</span> = <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>Tabs</span>[:len(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>Tabs</span>)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
			<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>Updated</span> = <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Now</span>()
			<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
		}
	}
	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
}
<span style=color:#75715e>// FindTab returns a tab if it exists
</span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Collection</span>) <span style=color:#a6e22e>FindTab</span>(<span style=color:#a6e22e>id</span> <span style=color:#a6e22e>tab</span>.<span style=color:#a6e22e>ID</span>) (<span style=color:#f92672>*</span><span style=color:#a6e22e>tab</span>.<span style=color:#a6e22e>Tab</span>, <span style=color:#66d9ef>bool</span>) {
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>t</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>Tabs</span> {
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>ID</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>id</span> {
			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>t</span>, <span style=color:#66d9ef>true</span>
		}
	}
	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#66d9ef>false</span>
}
<span style=color:#75715e>// UpdateTab updates a tab if it exists
</span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Collection</span>) <span style=color:#a6e22e>UpdateTab</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>tab</span>.<span style=color:#a6e22e>Tab</span>) <span style=color:#66d9ef>bool</span> {
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>tb</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>Tabs</span> {
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>tb</span>.<span style=color:#a6e22e>ID</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>ID</span> {
			<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>Tabs</span>[<span style=color:#a6e22e>i</span>] = <span style=color:#a6e22e>t</span>
			<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>Updated</span> = <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Now</span>()
			<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
		}
	}
	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
}
</code></pre></div><h5 id=聚合设计选择和优势>｜聚合设计选择和优势<a hidden class=anchor aria-hidden=true href=#聚合设计选择和优势>#</a></h5>
<p>聚合共享实体的相同设计选择；它是可变的，它有一个身份，并使用域值类型作为构建块。
它还使用为所包含的类型定义的无处不在的语言，并丰富了它，增加了它的一种。</p>
<p>实体和聚合的区别在于它可以是更多域类型的集群，也可以组合更多的聚合。</p>
<h5 id=聚合根>聚合根<a hidden class=anchor aria-hidden=true href=#聚合根>#</a></h5>
<p>聚合根表示与聚合相同的概念，唯一不同的是：它表示可用于在域用例中进行交互的聚合根。</p>
<p>这意味着，以极其简化的方式，聚合根拥有用于从数据库中检索它的标识符。</p>
<p>至于聚合，可以根据域将实体用作聚合根。</p>
<p>在文章开头共享的域中，<code>Workspace</code> 就是聚合根：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>workspace</span>
<span style=color:#f92672>import</span> (
    <span style=color:#e6db74>&#34;time&#34;</span>
    <span style=color:#e6db74>&#34;workspace/collection&#34;</span>
    <span style=color:#e6db74>&#34;workspace/collection/tab&#34;</span>
)
<span style=color:#75715e>// Workspace represent a workspace
</span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Workspace</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>ID</span>          <span style=color:#a6e22e>ID</span>
	<span style=color:#a6e22e>Name</span>        <span style=color:#a6e22e>Name</span>
	<span style=color:#a6e22e>CustomerID</span>  <span style=color:#a6e22e>CustomerID</span>
	<span style=color:#a6e22e>Collections</span> []<span style=color:#f92672>*</span><span style=color:#a6e22e>collection</span>.<span style=color:#a6e22e>Collection</span>
	<span style=color:#a6e22e>Created</span>     <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Time</span>
	<span style=color:#a6e22e>Updated</span>     <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Time</span>
}
<span style=color:#75715e>// New returns a workspace created for the first time
</span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>New</span>(<span style=color:#a6e22e>id</span> <span style=color:#a6e22e>ID</span>, <span style=color:#a6e22e>name</span> <span style=color:#a6e22e>Name</span>, <span style=color:#a6e22e>customerID</span> <span style=color:#a6e22e>CustomerID</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>Workspace</span> {
	<span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>Workspace</span>{
		<span style=color:#a6e22e>ID</span>:          <span style=color:#a6e22e>id</span>,
		<span style=color:#a6e22e>Name</span>:        <span style=color:#a6e22e>name</span>,
		<span style=color:#a6e22e>CustomerID</span>:  <span style=color:#a6e22e>customerID</span>,
		<span style=color:#a6e22e>Collections</span>: make([]<span style=color:#f92672>*</span><span style=color:#a6e22e>collection</span>.<span style=color:#a6e22e>Collection</span>, <span style=color:#ae81ff>0</span>),
		<span style=color:#a6e22e>Created</span>:     <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Now</span>(),
	}
}
<span style=color:#75715e>// Rename change the name of a workspace
</span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>w</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Workspace</span>) <span style=color:#a6e22e>Rename</span>(<span style=color:#a6e22e>name</span> <span style=color:#a6e22e>Name</span>) {
	<span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>Name</span> = <span style=color:#a6e22e>name</span>
	<span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>Updated</span> = <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Now</span>()
}
<span style=color:#75715e>// AddCollections add a collection
</span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>w</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Workspace</span>) <span style=color:#a6e22e>AddCollections</span>(<span style=color:#a6e22e>collections</span> <span style=color:#f92672>...*</span><span style=color:#a6e22e>collection</span>.<span style=color:#a6e22e>Collection</span>) {
	<span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>Collections</span> = append(<span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>Collections</span>, <span style=color:#a6e22e>collections</span><span style=color:#f92672>...</span>)
	<span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>Updated</span> = <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Now</span>()
}
<span style=color:#75715e>// RemoveCollection removes a collection if it exists
</span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>w</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Workspace</span>) <span style=color:#a6e22e>RemoveCollection</span>(<span style=color:#a6e22e>id</span> <span style=color:#a6e22e>collection</span>.<span style=color:#a6e22e>ID</span>) <span style=color:#66d9ef>bool</span> {
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>coll</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>Collections</span> {
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>coll</span>.<span style=color:#a6e22e>ID</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>id</span> {
			<span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>Collections</span>[<span style=color:#a6e22e>i</span>] = <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>Collections</span>[len(<span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>Collections</span>)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
			<span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>Collections</span>[len(<span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>Collections</span>)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] = <span style=color:#66d9ef>nil</span>
			<span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>Collections</span> = <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>Collections</span>[:len(<span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>Collections</span>)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
			<span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>Updated</span> = <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Now</span>()
			<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
		}
	}
	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
}
<span style=color:#75715e>// RenameCollection renames a collection if it exists
</span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>w</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Workspace</span>) <span style=color:#a6e22e>RenameCollection</span>(<span style=color:#a6e22e>id</span> <span style=color:#a6e22e>collection</span>.<span style=color:#a6e22e>ID</span>, <span style=color:#a6e22e>name</span> <span style=color:#a6e22e>collection</span>.<span style=color:#a6e22e>Name</span>) <span style=color:#66d9ef>bool</span> {
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>coll</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>Collections</span> {
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>coll</span>.<span style=color:#a6e22e>ID</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>id</span> {
			<span style=color:#a6e22e>coll</span>.<span style=color:#a6e22e>Rename</span>(<span style=color:#a6e22e>name</span>)
			<span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>Updated</span> = <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Now</span>()
			<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
		}
	}
	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
}
</code></pre></div><h5 id=放置它们的位置>|放置它们的位置<a hidden class=anchor aria-hidden=true href=#放置它们的位置>#</a></h5>
<p>在将领域表示为代码时，这三种模式是最重要的，因为它们是它的组成部分，所有的特征和不变量都围绕着它们。</p>
<p>由于这些非常重要，因此值得拥有自己的包，作为所有依赖于它们的领域类型的入口点。</p>
<pre tabindex=0><code>📂 app
 ┗ 📦workspace
   ┣ 📜id.go
   ┣ 📜name.go
   ┣ 📜workspace.go
   ┣ 📜 ...
   ┗ 📦collection
     ┣ 📜id.go
     ┣ 📜name.go
     ┣ 📜collection.go
     ┣ 📜 ...
     ┗ 📦tab
       ┣ 📜id.go
       ┣ 📜title.go
       ┣ 📜description.go
       ┣ 📜 ...
       ┗ 📜tab.go
</code></pre><p>在这个结构中，我将三者分开，因为作为集合的选项卡不需要它们的父项来存在和定义。而且，最重要的是，如果只需要一种，将它们拆分到不同的包中可以不导入所有域类型。</p>
<h4 id=存储库>存储库<a hidden class=anchor aria-hidden=true href=#存储库>#</a></h4>
<p>存储库模式可能是 <code>DDD</code> 世界中最著名的。</p>
<p>这种模式代表了一种机制，用于将域类型与持久性进行映射，公开模拟与内存切片交互的 <code>API</code>。</p>
<p>我通常将其表示为如下所示的接口：</p>
<pre tabindex=0><code>package tab
import &quot;errors&quot;
var( 
    //Errors returned by the repository
	ErrRepoNextID   = errors.New(&quot;tab: could not return next id&quot;)
	ErrRepoList     = errors.New(&quot;tab: could not list&quot;)
	ErrNotFound     = errors.New(&quot;tab: could not find&quot;)
	ErrRepoGet      = errors.New(&quot;tab: could not get&quot;)
	ErrRepoAdd      = errors.New(&quot;tab: could not add&quot;)
	ErrRepoRemove   = errors.New(&quot;tab: could not remove&quot;)
)
type Repo interface {
    // NextID returns the next free ID and an error in case of failure
    NextID() (ID, error)
    // List returns a tab slice and an error in case of failure
    List() ([]*Tab, error)
    // Find returns a tab or nil if it is not found and an error in case of failure
    Find(ID) (*Tab, error)
    // Get returns a tab and error in case is not found or failure
    Get(ID) (*Tab, error)
    // Add persists a tab (already existing or not) and returns an error in case of failure
    Add(*Tab) error
    // Remove removes a tab and returns and error in case is not found or failure
    Remove(ID) error
}
</code></pre><p>如果应用有读写分离的操作，可以这样表示：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>tab</span>
<span style=color:#75715e>// ...
</span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>ReadRepo</span> <span style=color:#66d9ef>interface</span> {
    <span style=color:#75715e>// List returns a tab slice and an error in case of failure
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>List</span>() ([]<span style=color:#f92672>*</span><span style=color:#a6e22e>Tab</span>, <span style=color:#66d9ef>error</span>)
    <span style=color:#75715e>// Find returns a tab or nil if it is not found and an error in case of failure
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>Find</span>(<span style=color:#a6e22e>ID</span>) (<span style=color:#f92672>*</span><span style=color:#a6e22e>Tab</span>, <span style=color:#66d9ef>error</span>)
    <span style=color:#75715e>// Get returns a tab and error in case is not found or failure
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>Get</span>(<span style=color:#a6e22e>ID</span>) (<span style=color:#f92672>*</span><span style=color:#a6e22e>Tab</span>, <span style=color:#66d9ef>error</span>)
}
<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>WriteRepo</span> <span style=color:#66d9ef>interface</span> {
    <span style=color:#75715e>// NextID returns the next free ID and an error in case of failure
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>NextID</span>() (<span style=color:#a6e22e>ID</span>, <span style=color:#66d9ef>error</span>)
    <span style=color:#75715e>// Add persists a tab (already existing or not) and returns an error in case of failure
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>Add</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>Tab</span>) <span style=color:#66d9ef>error</span>
    <span style=color:#75715e>// Remove removes a tab and returns and error in case is not found or failure
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>Remove</span>(<span style=color:#a6e22e>ID</span>) <span style=color:#66d9ef>error</span>
}
</code></pre></div><h5 id=存储库设计选择和优势>｜存储库设计选择和优势<a hidden class=anchor aria-hidden=true href=#存储库设计选择和优势>#</a></h5>
<p>从设计和技术的角度来看，存储库模式提供了多种优势。</p>
<p>采用这种模式允许将应用程序与特定数据库（例如 <code>MySQL</code>、<code>MongoDB</code> 或 <code>Google Spanner</code> ）解耦，这些好处会在测试期间出现，因为可以编写内存存储库实现，以及在迁移到不同数据库期间。</p>
<p>迁移应用程序以使用不同的数据库一直是一项昂贵的操作，但使用这种模式可以降低成本，因为只需要创建或更新一个存储库实现即可使用新数据库，并且存储库接口可以避免更新整个代码库。</p>
<p>为了便于迁移，将存储库及其报错定义放在同一个包中也是必不可少的，因此，即使对于错误检查，也只有拥有存储库接口的包与整个应用程序耦合。</p>
<p>是否可以在需要时从包含存储库实现的包中丰富已经指定的存储库错误：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>MysqlRepo</span>) <span style=color:#a6e22e>Add</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Tab</span>) <span style=color:#66d9ef>error</span> {
<span style=color:#75715e>// ...
</span><span style=color:#75715e></span><span style=color:#66d9ef>return</span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;%w: %s&#34;</span>, <span style=color:#a6e22e>tab</span>.<span style=color:#a6e22e>ErrRepoAdd</span>, <span style=color:#e6db74>&#34;a more detailed reason here&#34;</span>)
}
</code></pre></div><p>从设计的角度来看，应用存储库模式有助于定义上下文的清晰边界，并使其与不相关的子域分离，因为它的 <code>API</code> 主要（但不仅限于）使用聚合根及其 <code>ID</code> 。</p>
<p>存储库模式 <code>API</code> 还强制使用和建立通用语言，例如，可以在读取操作中使用过滤器参数并为该需求指定更具体的 <code>API</code>。</p>
<p>在需要过滤的地方，大多数时候，可以声明一个使用泛在语言的专用函数，减少认知负担和应用程序的复杂性。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// Don&#39;t
</span><span style=color:#75715e></span><span style=color:#a6e22e>repo</span>.<span style=color:#a6e22e>List</span>(<span style=color:#a6e22e>repo</span>.<span style=color:#a6e22e>Filter</span>{<span style=color:#e6db74>&#34;active&#34;</span>: <span style=color:#66d9ef>true</span>})
<span style=color:#75715e>// Do
</span><span style=color:#75715e></span><span style=color:#a6e22e>repo</span>.<span style=color:#a6e22e>ListActive</span>()
</code></pre></div><h5 id=放在哪里-1>|放在哪里<a hidden class=anchor aria-hidden=true href=#放在哪里-1>#</a></h5>
<p>与往常一样，我确实将有关存储库接口的文件放在拥有聚合的包中。</p>
<p>但是有关实现的文件，例如要对 MySQL 数据库执行查询的文件，我通常将它放在内部目录中，因为这些文件与应用程序高度耦合，不应在不同地方重复使用。</p>
<pre tabindex=0><code>📂 app
 ┣ 📦internal
 ┃ ┗ 📦tab
 ┃   ┗ 📜repo.go // here a MySQL implementation
 ┗ 📦tab
   ┗ 📜repo.go // here a the interface and the errors
</code></pre><h2 id=结论>结论<a hidden class=anchor aria-hidden=true href=#结论>#</a></h2>
<p>将 <code>DDD</code> 方法应用于代码时，战术设计是 <code>101</code>，但重要的是不要强迫语言遵循不适合它的习惯用法。在不使用 <code>DTO</code>、<code>始终有效的对象</code> 或其他源自面向对象世界的模式的情况下，也可以达到相同的目标。</p>
<p>这与 <code>Golang</code> 中的战略设计方法相结合，可为你提供清晰且最小的 <code>DDD</code> 代码库。</p>
<p>你不同意我和我的设计方法吗？请随时在下面的评论中分享你在 <code>Go</code> 中开发代码库时所做的主要决定！</p>
<p>注意：本文是关于 DDD 和 Golang 的系列文章的一部分，如果你有兴趣了解有关特定主题的更多信息，请告诉我！</p>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://www.ax4j.com/tags/go/>Go</a></li>
<li><a href=https://www.ax4j.com/tags/ddd/>DDD</a></li>
</ul>
<div class=share-buttons>
<a target=_blank rel="noopener noreferrer" aria-label="share Golang 中的领域驱动设计 - 战术设计 on twitter" href="https://twitter.com/intent/tweet/?text=Golang%20%e4%b8%ad%e7%9a%84%e9%a2%86%e5%9f%9f%e9%a9%b1%e5%8a%a8%e8%ae%be%e8%ae%a1%20-%20%e6%88%98%e6%9c%af%e8%ae%be%e8%ae%a1&url=https%3a%2f%2fwww.ax4j.com%2fposts%2fddd-using-golang-tactical-design%2f&hashtags=Go%2cDDD"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Golang 中的领域驱动设计 - 战术设计 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fwww.ax4j.com%2fposts%2fddd-using-golang-tactical-design%2f&title=Golang%20%e4%b8%ad%e7%9a%84%e9%a2%86%e5%9f%9f%e9%a9%b1%e5%8a%a8%e8%ae%be%e8%ae%a1%20-%20%e6%88%98%e6%9c%af%e8%ae%be%e8%ae%a1&summary=Golang%20%e4%b8%ad%e7%9a%84%e9%a2%86%e5%9f%9f%e9%a9%b1%e5%8a%a8%e8%ae%be%e8%ae%a1%20-%20%e6%88%98%e6%9c%af%e8%ae%be%e8%ae%a1&source=https%3a%2f%2fwww.ax4j.com%2fposts%2fddd-using-golang-tactical-design%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Golang 中的领域驱动设计 - 战术设计 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fwww.ax4j.com%2fposts%2fddd-using-golang-tactical-design%2f&title=Golang%20%e4%b8%ad%e7%9a%84%e9%a2%86%e5%9f%9f%e9%a9%b1%e5%8a%a8%e8%ae%be%e8%ae%a1%20-%20%e6%88%98%e6%9c%af%e8%ae%be%e8%ae%a1"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Golang 中的领域驱动设计 - 战术设计 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwww.ax4j.com%2fposts%2fddd-using-golang-tactical-design%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Golang 中的领域驱动设计 - 战术设计 on whatsapp" href="https://api.whatsapp.com/send?text=Golang%20%e4%b8%ad%e7%9a%84%e9%a2%86%e5%9f%9f%e9%a9%b1%e5%8a%a8%e8%ae%be%e8%ae%a1%20-%20%e6%88%98%e6%9c%af%e8%ae%be%e8%ae%a1%20-%20https%3a%2f%2fwww.ax4j.com%2fposts%2fddd-using-golang-tactical-design%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Golang 中的领域驱动设计 - 战术设计 on telegram" href="https://telegram.me/share/url?text=Golang%20%e4%b8%ad%e7%9a%84%e9%a2%86%e5%9f%9f%e9%a9%b1%e5%8a%a8%e8%ae%be%e8%ae%a1%20-%20%e6%88%98%e6%9c%af%e8%ae%be%e8%ae%a1&url=https%3a%2f%2fwww.ax4j.com%2fposts%2fddd-using-golang-tactical-design%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg>
</a>
</div>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2021 </span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>